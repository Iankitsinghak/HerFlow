/**
 * Core Philosophy: This ruleset enforces a dual security model. For sensitive, personal data
 * (profiles, cycle logs, doctor questions), it uses a strict user-ownership model where only
 * the creator can access their data. For public content (blog posts, community posts), it
 * employs a "public read, owner write" model, allowing anyone to view the content but
 * restricting modifications to the original author.
 *
 * Data Structure: The data is structurally segregated based on access patterns. All private
 * user data is nested within a user-specific path, `/users/{userId}`, which simplifies and
 * strengthens ownership rules. Publicly-contributed content resides in top-level collections
 * like `/blogPosts` and `/communityPosts`.
 *
 * Key Security Decisions:
 * - Default Deny: All access is denied by default unless explicitly granted.
 * - No User Listing: It is not possible to list documents in the top-level `/users` collection.
 * - Private Data Isolation: Data in `/users/{userId}` subcollections is strictly confined to the
 *   owner, preventing any cross-user data leakage.
 * - Public Content Integrity: While `blogPosts` and `communityPosts` are publicly readable,
 *   only the authenticated author can create, update, or delete their own posts.
 * - Read-Only Tags: The `/tags` collection is publicly readable but not writable by clients to
 *   prevent spam and maintain data quality. Tag management should be handled by a trusted
 *   backend process or admin role (not defined in this ruleset).
 *
 * Denormalization for Authorization: To ensure fast and simple authorization checks, this
 * ruleset relies on denormalized ownership fields. For example, `blogPosts` and `communityPosts`
 * contain an `authorId`, and all documents within the `/users/{userId}` path contain a `userId`.
 * This avoids costly and complex cross-collection `get()` calls in rules.
 *
 * Structural Segregation: The separation of private data into user subcollections (`/users/{userId}/cycleLogs`)
 * and public data into top-level collections (`/blogPosts`) is a deliberate design choice. It makes
 * list operations more secure and performant, as rules can safely grant list access on an entire
 * collection without needing to filter the results.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user's UID matches the provided userId.
    // Used for path-based ownership checks.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Checks for ownership on an existing document.
    // CRITICAL: Used for update/delete to prevent acting on non-existent data.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Validates that the incoming document's userId field matches the userId from the path.
    // Enforces relational integrity on document creation.
    function incomingDataMatchesOwnershipPath(userId) {
      return request.resource.data.userId == userId;
    }

    // Validates that an ownership field (e.g., userId, authorId) is not being changed.
    // Enforces immutability of ownership on document updates.
    function isOwnershipFieldImmutable(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }

    /**
     * @description Controls access to a user's private profile. Only the owner can read or write their own profile.
     * @path /users/{userId}/userProfiles/{profileId}
     * @allow (auth.uid="user123") -> (create) /users/user123/userProfiles/user123 with {userId: "user123"}
     * @deny  (auth.uid="user456") -> (get) /users/user123/userProfiles/user123
     * @principle Restricts access to a user's own data tree and enforces relational integrity.
     */
    match /users/{userId}/userProfiles/{profileId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && incomingDataMatchesOwnershipPath(userId);
      allow update: if isExistingOwner(userId) && isOwnershipFieldImmutable('userId');
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's private cycle logs. This data is highly sensitive and strictly owned.
     * @path /users/{userId}/cycleLogs/{cycleLogId}
     * @allow (auth.uid="user123") -> (get) /users/user123/cycleLogs/log-abc
     * @deny  (auth.uid="user456") -> (list) /users/user123/cycleLogs
     * @principle Restricts access to a user's own data tree and enforces relational integrity.
     */
    match /users/{userId}/cycleLogs/{cycleLogId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && incomingDataMatchesOwnershipPath(userId);
      allow update: if isExistingOwner(userId) && isOwnershipFieldImmutable('userId');
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's private questions for doctors. This data is sensitive and strictly owned.
     * @path /users/{userId}/doctorQuestions/{questionId}
     * @allow (auth.uid="user123") -> (delete) /users/user123/doctorQuestions/q-abc
     * @deny  (auth.uid="user456") -> (create) /users/user123/doctorQuestions/q-def with {userId: "user123"}
     * @principle Restricts access to a user's own data tree and enforces relational integrity.
     */
    match /users/{userId}/doctorQuestions/{questionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && incomingDataMatchesOwnershipPath(userId);
      allow update: if isExistingOwner(userId) && isOwnershipFieldImmutable('userId');
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Publicly readable blog posts. Any signed-in user can create a post, but only the author can edit or delete it.
     * @path /blogPosts/{blogPostId}
     * @allow (unauthenticated) -> (get) /blogPosts/post-abc
     * @deny  (auth.uid="user456") -> (update) /blogPosts/post-abc (where post-abc has authorId: "user123")
     * @principle Enforces document ownership for writes while allowing public read access.
     */
    match /blogPosts/{blogPostId} {
      allow get: if true;
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId) && isOwnershipFieldImmutable('authorId');
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Publicly readable community posts. Any signed-in user can create a post, but only the author can edit or delete it.
     * @path /communityPosts/{communityPostId}
     * @allow (auth.uid="user123") -> (create) /communityPosts/post-xyz with {authorId: "user123"}
     * @deny  (auth.uid="user456") -> (delete) /communityPosts/post-xyz (where post-xyz has authorId: "user123")
     * @principle Enforces document ownership for writes while allowing public read access.
     */
    match /communityPosts/{communityPostId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId) && isOwnershipFieldImmutable('authorId');
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Globally readable tags for categorizing content. No client-side writes are allowed to maintain data quality.
     * @path /tags/{tagId}
     * @allow (any user) -> (list) /tags
     * @deny  (any user) -> (create, update, delete) /tags/new-tag
     * @principle Secures a global, read-only collection to prevent client-side data pollution.
     */
    match /tags/{tagId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}